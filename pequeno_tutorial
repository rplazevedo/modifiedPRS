no ficheiro setup.py tens de escrever os ficheiros que vão ser compilados (neste caso só tens lá escrito o "sPRS.pyx" e o "merge_v.pyx").

depois tens de escrever na linah de comandos python3 setup.py build_ext --inplace


o sPRS.pyx é um cálculo standard PRS (nas equaçãoes não vês o a^(beta) porque como eu considerei beta =0, não coloquei esse termo). Na próxima versão envio-te com esse termo.
O outputs deste cálculo ficheiro são arrays com o tamanho que escolhes para "Points in time interval per part":

nop_datax.npy        (number of operations per part=x)
nwalls_datax.npy     (number of wall points per part)
tspan_datax.npy      (range of conformal time for each part)
vdataxx.npy          ((gamma*velocity)**2)

o merge_v.pyx é para fazer um merge dos ficheiros outputs que são gravados durante o cálculo sPRS.pyx. 
Se queres um cálculo com in range de 1000 eta, então dado que no settings.ini  tens um intervalo de 0.1 para o eta, podes fazer um cálculo com 100 pontos por intervalo e fazer 100 partes.
Vais ter 100000 pontos que corresponde a 1000 eta. O merge_v.pyx vai juntar o number of operations, nwalls e vdata num só:

nop.data
v.data
nwalls.data







Exemplo:  512**2


Muda o settings ini para Lattice_size = 512
Deixa o resto igual (podes ver a definição de cada parame. do settings.ini no código sPRS.pyx)
Compila os ficheiros *.pyx ("python3 setup.py build_ext --inplace")
Abre o python3 e faz 

import sPRS

Points in time interval per part?  

-escreve 100

How many parts
-escreve 50  para teres 5000 pontos (range de 500 eta). demora ~25 segundos no meu portátil

agora escreve:  

import merge_v
How many parts:

-50  (tem de ser igual ao de cima)

Points on time interval per part?
-100  (desculpa a ordem n ser a mesma da de cima, n mudei isso ainda)

Sais do python e já deves ver o v.data, nop.data e nwalls.data
Podes fazer plot e ver os resultados.

O ficheiro "reduce_data_points.py" é para reduzir o número de pontos ns ficheiros v.data, nop.data e nwalls.data. 

Abred esse ficheiro, metes parts =50 e deixas o resto. 
Depois fazes python3 reduce_data_points.py

Novos ficheiros v.txt, nop.txt e nwalls.txt.  (notei que o último ponto não está correcto)

Provavelmente vais ter maus resultados com 512. Tenta com 1024.



Estes são os ficheiros principais para o cálculo cython:
 
-c_dw.pyx  (standard PRS)

-read_cw_cont.pyx  (standard PRS)  basicamente lê a última parte do cálculo feito no c_dw.pyx e recomeça o cálculo. 

-o2read_cw_cont.pyx (not standard PRS but with a fixed mesh) neste vês que há dois parâmetros alpha1 e alpha2 que são aqueles parâmetros para fixar os vácuos.)

Seria interessante correr c_dw  até (x parts) e depois o read_cw_cont (até x+y parts)  e fazer plot da velocidade (como no primeiro tutorial que te enviei).
Depois corrias o2read_cw_cont (até x+y parts) fazias plot da velocidade e comparar com o resultado anterior. Foi isto que fiz quando estudei a influência dos parâmetros alpha1 e alpha2.

Já te expliquei o merge_v.pyx,  o reduce_data_points.py.

Se por acaso no ficheiro .ini   (input ini)  escreveres all_phi=yes, vais gravar os dados do campo escalar phi (isto vai tornar os cálculos mais lentos).
Com a data do campo escalar podes usar o merge_phi.pyx para fazer merge de todas as partes.
Isto vai criar um ficheiro que vai acabar em  "mymemmap".  Eu crei um script (anim_dw1.py) para fazer plot da evolução do campo escalar.

Os outros ficheiros .pyx não interessam (ou são repetidos, ou versões antigas, ou então tentativas para novas versões que não deram em nada).


Para o python na pasta mesh free  tens o read_new6.py (lê a última parte do cálculo standard PRS pelo c_dw.pyx) e depois faz um cálculo com uma rede ('lista') dinâmica.

Para fazer um comparação do read_new6.py com o o2read_cw_con.pyx, o que eu fiz foi criar uma versão do  o2read_cw_con.pyx patra python que é o read.py.

Portanto o procedimento para verificar que está tudo bem é (fazer um cálculo c_dw.pyx, read.py e depois read_new6.pyx).

Agora acho que o código read_new6.pyx é muito confuso e eu gostava de o tentar tornar mais claro dividindo-do em funções ou algo. Mas primeiro vou meter comentários ou algo.
 
